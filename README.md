*This project has been created as part of the 42 curriculum by selevray.*

# Push_swap

## Description
The **Push_swap** project is an algorithmic exercise that involves sorting a stack of numbers using a limited set of instructions. The goal is to find the shortest sequence of instructions possible.

My solution is based on a **doubly circular linked list**. This data structure, where each node points to both the next and previous elements and the last node links back to the first, is ideal for simulating the circular behavior of stacks required by the subject (facilitating rotations like `ra`, `rb`, `rra`, and `rrb`).



The sorting algorithm used is an **optimized Insertion Sort** driven by a **cost analysis**: for each number, the program calculates the number of rotations required in both stacks to insert it into its ideal position, always choosing the cheapest operation (an approach similar to the "Turk Algorithm").

---

### ðŸ“Š Performance

My algorithm significantly exceeds the requirements of the 42 project rubric:

| Number of elements | Performance (Average) | 42 Objective (Max) |
| :--- | :---: | :---: |
| **3 numbers** | `2 moves` | 3 moves |
| **5 numbers** | `8 moves` | 12 moves |
| **100 numbers** | `577 moves` | 700 moves |
| **500 numbers** | `4588 moves` | 5500 moves |

> _Tests were conducted with randomly generated lists over 100 iterations._

---

## ðŸ› ï¸ Instructions

### Compilation
The project is compiled using the provided `Makefile`:
```bash
make          # Compiles push_swap
make bonus    # Compiles the checker
make clean    # Removes object files
make fclean   # Removes all compiled files
```

### Execution
```bash 
# Run Push_swap
./push_swap 4 75 12 2 0
./push_swap "4 75 12 2 0"
# Run Push_swap with the checker (Bonus)
ARG="4 1 2"; ./push_swap $ARG | ./checker $ARG
# Expected result: OK
```

## Resources

### ðŸ§  Algorithmes
* **[Insertion Sort (Explications)](https://www.geeksforgeeks.org/dsa/insertion-sort-algorithm/)** : Understanding the logic of element-by-element insertion sorting..

### ðŸ› ï¸ Tools & Testers
* **[Push_swap Visualizer](https://github.com/o-reo/push_swap_visualizer)** : Essential tool to visualize the algorithm in real-time..
* **[Push_swap Tester](https://github.com/SimonCROS/push_swap_tester)** : A suite of tests to validate performance and logic.

### ðŸ¤– AI Usage Disclosure
* **Debugging Assistance :** Analysis of specific code segments to identify memory leaks or segmentation faults.
* **Conceptual Learning :** Comparative study of various sorting algorithms (Bubble, Quick, Radix) to select the most efficient one for this project.
* **Concept Clarification :** Deep dives into cost calculation logic for movement optimization.
* **README Optimization :** Assistance with formatting and structuring this documentation.

### ðŸš« What AI did NOT do:
* **Algorithmic Logic :** The final sorting strategy and the implementation of cost functions were designed and coded manually.
* **Architecture du Code :** The design of the linked lists and the global management of the stacks are my own work.
* **Zero AI Code Generation**: No source code (neither `.c` nor `.h` files), no algorithmic logic, and no project-related scripts were generated by artificial intelligence. The entirety of the code was manually authored to ensure a comprehensive understanding of the underlying concepts and to maintain strict pedagogical integrity.

> **Note :** AI was used as a supportive tool to accelerate learning. Every line of code was written, tested, and fully understood by me to ensure total mastery of the project during evaluation.